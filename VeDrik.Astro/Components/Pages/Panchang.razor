@page "/Panchang"

@using SwissEphNet
@using VeDrik.Astro.Data

<PageTitle>Vedic Day Info</PageTitle>

<div class="container-fluid">
    <h3 class="text-center mb-4">Vedic Day Information</h3>
    <div class="card mb-4">
        <div class="card-header bg-primary text-white">
            <h5 class="mb-0">Today's Panchang Categories</h5>
            <h6>  @horaNote </h6>
        </div>
        <div class="card-body">
            <table class="table table-bordered">
                <tbody>
                    <tr><th>Tithi   </th><td>@tithi</td></tr>
                    <tr><th>Vara    </th><td>@weekday</td></tr>
                    <tr><th>Nakshatra </th><td>@nakshatra</td></tr>
                    <tr><th>Yoga   </th><td>@yoga</td></tr>
                    <tr><th>Karana </th><td>@karana</td></tr>
                </tbody>
            </table>
        </div>
    </div>
    <div class="card mb-4">
        <div class="card-header bg-secondary text-white">
            <h5 class="mb-0">Other Vedic Details</h5>
        </div>
        <div class="card-body">
            <table class="table table-bordered">
                <tbody>
                    <tr><th>Vedic Month</th><td>@vedicMonth</td></tr>
                    <tr><th>Hora (Current)</th><td>@hora</td></tr>
                    <tr><th>Hora Start</th><td>@horaStart - @horaEnd </td></tr>
                    <tr><th>Lagna (Ascendant)</th><td>@lagna</td></tr>
                    <tr><th>Rahu Kaal</th><td>@rahuKaal</td></tr>
                    <tr><th>Yama Kaal</th><td>@yamaKaal</td></tr>
                    <tr><th>Subha Samaya</th><td>@subhaSamaya</td></tr>
                    <tr><th>Vardhyam</th><td>@vardhyam</td></tr>
                    <tr><th>Dhurmuhurtham</th><td>@dhurmuhurtham</td></tr>
                </tbody>
            </table>
        </div>
    </div>
    <div class="card mb-4">
        <div class="card-header bg-info text-white">
            <h5 class="mb-0">Subha Samaya and Other Auspicious Times</h5>
        </div>
        <div class="card-body">
            <table class="table table-bordered">
                <tbody>
                    <tr><th>Subha Samaya</th><td>@subhaSamaya</td></tr>
                    <tr><th>Vardhyam</th><td>@vardhyam</td></tr>
                    <tr><th>Dhurmuhurtham</th><td>@dhurmuhurtham</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    @if (horaSchedule.Any())
    {
        <div class="card mb-4">
            <div class="card-header bg-warning">
                <h5 class="mb-0">Hora Schedule (Sunrise to next Sunrise)</h5>
            </div>
            <div class="card-body">
                <small class="text-muted">@horaNote</small>
                <div class="table-responsive mt-2">
                    <table class="table table-sm table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>Start - End</th>
                                <th>Lord</th>
                                <th>Day/Night</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var h in horaSchedule)
                            {
                                <tr>
                                    <td>@h.Start - @h.End</td>
                                    <td><span class="badge bg-info">@h.Lord</span></td>
                                    <td>@(h.IsDay ? "Day" : "Night")</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    }
</div>

@code {
    // Location and time settings (can be parameterized)
    double longitude = 82.0061; // Amalapuram
    double latitude = 16.5786;
    double timezone = 5.5; // IST
    DateTime now;

    string weekday = string.Empty;
    string vedicMonth = string.Empty;
    string tithi = string.Empty;
    string hora = string.Empty;
    string horaStart = string.Empty;
    string horaEnd = string.Empty;
    string lagna = string.Empty;
    string rahuKaal = string.Empty;
    string yamaKaal = string.Empty;
    string nakshatra = string.Empty;
    string yoga = string.Empty;
    string karana = string.Empty;
    string subhaSamaya = string.Empty;
    string vardhyam = string.Empty;
    string dhurmuhurtham = string.Empty;

    // sunrise/sunset cache
    DateTime sunriseCached;
    DateTime sunsetCached;
    DateTime nextSunriseCached;

    // Hora schedule support
    class HoraPeriod
    {
        public int Index { get; set; }
        public string Start { get; set; } = string.Empty;
        public string End { get; set; } = string.Empty;
        public string Lord { get; set; } = string.Empty;
        public bool IsDay { get; set; }
        public DateTime StartLocal { get; set; }
        public DateTime EndLocal { get; set; }
    }
    List<HoraPeriod> horaSchedule = new();
    string horaNote = string.Empty;

    protected override void OnInitialized()
    {
        now = DateTime.UtcNow.AddHours(timezone);
        CalculateVedicDayInfo();
        BuildHoraSchedule();
        ComputeDayAuspiciousWindows();
    }

    void CalculateVedicDayInfo()
    {
        // Weekday and Vedic Month
        (weekday, vedicMonth) = (VedicConstants.Weekdays[(int)now.DayOfWeek], VedicConstants.VedicMonths[(now.Month - 1) % 12]);

        // Sun/Moon calculations for Panchang elements
        var sweph = new SwissEph();
        double jut = now.Hour + (now.Minute / 60.0) + (now.Second / 3600.0);
        double jd = sweph.swe_julday(now.Year, now.Month, now.Day, jut, SwissEph.SE_GREG_CAL);
        double[] sun = new double[6], moon = new double[6];
        string serr = string.Empty;
        sweph.swe_calc(jd, SwissEph.SE_SUN, SwissEph.SEFLG_SIDEREAL, sun, ref serr);
        sweph.swe_calc(jd, SwissEph.SE_MOON, SwissEph.SEFLG_SIDEREAL, moon, ref serr);

        // Tithi
        string[] tithiNames = new string[] {
            "Pratipada (Shukla)", "Dvitiya (Shukla)", "Tritiya (Shukla)", "Chaturthi (Shukla)", "Panchami (Shukla)", "Shashthi (Shukla)", "Saptami (Shukla)", "Ashtami (Shukla)", "Navami (Shukla)", "Dashami (Shukla)", "Ekadashi (Shukla)", "Dwadashi (Shukla)", "Trayodashi (Shukla)", "Chaturdashi (Shukla)", "Purnima",
            "Pratipada (Krishna)", "Dvitiya (Krishna)", "Tritiya (Krishna)", "Chaturthi (Krishna)", "Panchami (Krishna)", "Shashthi (Krishna)", "Saptami (Krishna)", "Ashtami (Krishna)", "Navami (Krishna)", "Dashami (Krishna)", "Ekadashi (Krishna)", "Dwadashi (Krishna)", "Trayodashi (Krishna)", "Chaturdashi (Krishna)", "Amavasya"
        };
        double elong = (moon[0] - sun[0] + 360) % 360;
        int tithiNum = (int)(elong / 12.0) + 1;
        if (tithiNum > 30) tithiNum = 30;
        tithi = tithiNames[tithiNum - 1];

        // Nakshatra
        int nakshatraNum = (int)(moon[0] / (360.0 / 27)) + 1;
        nakshatra = VedicConstants.NakshatraNames[(nakshatraNum - 1) % 27];

        // Yoga
        double yogaValue = (sun[0] + moon[0]) % 360;
        int yogaNum = (int)(yogaValue / (360.0 / 27)) + 1;
        yoga = VedicConstants.YogaNames[(yogaNum - 1) % 27];

        // Karana
        int karanaNum = ((int)((elong % 360) / 6.0)) % 11;
        karana = VedicConstants.KaranaNames[karanaNum];

        // Hora display is set from schedule
        hora = ""; horaStart = ""; horaEnd = "";

        // Lagna (approximate)
        int lagnaIndex = (((now.Hour - 6) + 24) % 12);
        lagna = VedicConstants.RasiNames[lagnaIndex];

        sweph.Dispose();
    }

    string GetDayLordName(DateTime localDate)
    {
        string[] dayLords = ["Sun", "Moon", "Mars", "Mercury", "Jupiter", "Venus", "Saturn"]; // Sunday..Saturday
        int idx = (int)localDate.DayOfWeek; // 0..6
        return dayLords[idx];
    }

    // Convert a local DateTime to its Julian Day UT value
    double ToJulianDayUT(DateTime local)
    {
        var utc = local.AddHours(-timezone);
        double utHour = utc.Hour + (utc.Minute / 60.0) + (utc.Second / 3600.0);
        var swe = new SwissEph();
        double jd = swe.swe_julday(utc.Year, utc.Month, utc.Day, utHour, SwissEph.SE_GREG_CAL);
        swe.Dispose();
        return jd;
    }

    // Convert Julian Day UT to local DateTime
    DateTime FromJulianDayUTToLocal(double jdUt)
    {
        var swe = new SwissEph();
        int y = 0, m = 0, d = 0; double h = 0;
        swe.swe_revjul(jdUt, SwissEph.SE_GREG_CAL, ref y, ref m, ref d, ref h);
        swe.Dispose();
        var utc = new DateTime(y, m, d).AddHours(h);
        return utc.AddHours(timezone);
    }

    bool TryGetSunriseSunset(DateTime localDate, out DateTime sunriseLocal, out DateTime sunsetLocal, out string error)
    {
        sunriseLocal = localDate.Date.AddHours(6);
        sunsetLocal = localDate.Date.AddHours(18);
        error = string.Empty;
        try
        {
            var swe = new SwissEph();
            double jd0 = ToJulianDayUT(localDate.Date); // UT JD for local midnight
            double[] geopos = new double[] { longitude, latitude, 0 }; // altitude meters if available
            double tret = 0;
            string serr = string.Empty;
            int epheflag = 0; // default Swiss Ephemeris

            // Use upper limb + standard refraction (no special bits)
            int rsmiRise = SwissEph.SE_CALC_RISE;
            int rsmiSet  = SwissEph.SE_CALC_SET;

            // Standard atmosphere to match common portals
            double atpress = 1013.25; // mbar
            double attemp  = 15.0;    // °C

            int rc1 = swe.swe_rise_trans(jd0, SwissEph.SE_SUN, null, epheflag, rsmiRise, geopos, atpress, attemp, ref tret, ref serr);
            if (rc1 >= 0)
                sunriseLocal = FromJulianDayUTToLocal(tret);

            tret = 0; serr = string.Empty;
            int rc2 = swe.swe_rise_trans(jd0, SwissEph.SE_SUN, null, epheflag, rsmiSet, geopos, atpress, attemp, ref tret, ref serr);
            if (rc2 >= 0)
                sunsetLocal = FromJulianDayUTToLocal(tret);

            swe.Dispose();
            return rc1 >= 0 && rc2 >= 0;
        }
        catch (Exception ex)
        {
            error = ex.Message;
            return false;
        }
    }

    void BuildHoraSchedule()
    {
        horaSchedule.Clear();

        var localDate = now.Date; // local date used for schedule

        // Get precise sunrise and sunset for the date and next sunrise
        _ = TryGetSunriseSunset(localDate, out var sunrise, out var sunset, out var _);
        _ = TryGetSunriseSunset(localDate.AddDays(1), out var nextSunrise, out var _, out var _2);

        // Fallbacks if needed
        if (sunrise == default)
            sunrise = localDate.AddHours(6);
        if (sunset == default)
            sunset = localDate.AddHours(18);
        if (nextSunrise == default)
            nextSunrise = localDate.AddDays(1).AddHours(6);

        if (nextSunrise <= sunset)
        {
            nextSunrise = nextSunrise.AddDays(1);
        }

        // cache
        sunriseCached = sunrise;
        sunsetCached = sunset;
        nextSunriseCached = nextSunrise;

        var dayDuration = sunset - sunrise;
        var nightDuration = nextSunrise - sunset;

        var dayHora = TimeSpan.FromTicks(dayDuration.Ticks / 12);
        var nightHora = TimeSpan.FromTicks(nightDuration.Ticks / 12);

        string dayLord = GetDayLordName(localDate);
        int startIndex = Array.IndexOf(VedicConstants.HoraLords, dayLord);
        if (startIndex < 0) startIndex = 0;

        // Build 12 day horas
        for (int i = 0; i < 12; i++)
        {
            int lordIndex = (startIndex + i) % VedicConstants.HoraLords.Length;
            var start = sunrise.AddTicks(dayHora.Ticks * i);
            var end = start.Add(dayHora);
            horaSchedule.Add(new HoraPeriod
            {
                Index = i + 1,
                Start = start.ToString("HH:mm"),
                End = end.ToString("HH:mm"),
                Lord = VedicConstants.HoraLords[lordIndex],
                IsDay = true,
                StartLocal = start,
                EndLocal = end
            });
        }

        // Night horas
        for (int i = 0; i < 12; i++)
        {
            int lordIndex = (startIndex + 12 + i) % VedicConstants.HoraLords.Length;
            var start = sunset.AddTicks(nightHora.Ticks * i);
            var end = start.Add(nightHora);
            horaSchedule.Add(new HoraPeriod
            {
                Index = 12 + i + 1,
                Start = start.ToString("HH:mm"),
                End = end.ToString("HH:mm"),
                Lord = VedicConstants.HoraLords[lordIndex],
                IsDay = false,
                StartLocal = start,
                EndLocal = end
            });
        }

        horaNote = $"Sunrise: {sunrise:HH:mm}, Sunset: {sunset:HH:mm}, Next Sunrise: {nextSunrise:HH:mm}. Day hora: {dayHora.TotalMinutes:F0} min, Night hora: {nightHora.TotalMinutes:F0} min.";

        // Update current hora info accurately
        var current = horaSchedule.FirstOrDefault(h => now >= h.StartLocal && now < h.EndLocal);
        if (current != null)
        {
            hora = current.Lord;
            horaStart = current.Start;
            horaEnd = current.End;
        }
    }

    // Compute Rahu Kaal, Yamagandam, Durmuhurtham, Vardhyam and Subha Samaya dynamically
    void ComputeDayAuspiciousWindows()
    {
        // Require sunrise/sunset
        var sunrise = sunriseCached == default ? now.Date.AddHours(6) : sunriseCached;
        var sunset = sunsetCached == default ? now.Date.AddHours(18) : sunsetCached;

        var dayLen = sunset - sunrise;
        if (dayLen.TotalMinutes <= 0)
        {
            rahuKaal = yamaKaal = dhurmuhurtham = subhaSamaya = vardhyam = "N/A";
            return;
        }

        // Segment the day into 8 equal parts
        var octant = TimeSpan.FromTicks(dayLen.Ticks / 8);

        // Standard segment indices (1..8) from sunrise
        int dow = (int)now.DayOfWeek; // 0..6, 0=Sunday
        int[] rahuIndex = [8, 2, 7, 5, 6, 4, 3];
        int[] yamaIndex = [5, 4, 3, 2, 1, 7, 6];

        // Rahu Kaal
        var rkStart = sunrise.AddTicks(octant.Ticks * (rahuIndex[dow] - 1));
        var rkEnd = rkStart.Add(octant);
        rahuKaal = $"{rkStart:HH:mm}-{rkEnd:HH:mm}";

        // Yama Kaal (Yamagandam)
        var ygStart = sunrise.AddTicks(octant.Ticks * (yamaIndex[dow] - 1));
        var ygEnd = ygStart.Add(octant);
        yamaKaal = $"{ygStart:HH:mm}-{ygEnd:HH:mm}";

        // Durmuhurtham (muhurta = 1/30th of day from sunrise)
        var muhurta = TimeSpan.FromTicks(dayLen.Ticks / 30);
        List<int[]> durmuhurtaMap = new()
        {
            new[]{16,21}, // Sunday
            new[]{8,12},  // Monday
            new[]{3,10},  // Tuesday
            new[]{7},     // Wednesday
            new[]{10,14}, // Thursday
            new[]{6},     // Friday
            new[]{13,20}  // Saturday
        };
        var dayDurMuh = durmuhurtaMap[dow];
        List<string> durStrings = new();
        foreach (var idx in dayDurMuh)
        {
            var s = sunrise.AddTicks(muhurta.Ticks * (idx - 1));
            var e = s.Add(muhurta);
            durStrings.Add($"{s:HH:mm}-{e:HH:mm}");
        }
        dhurmuhurtham = durStrings.Count == 0 ? "None" : string.Join(", ", durStrings);

        // Vardhyam -> Abhijit Muhurta (1/15th of day centered at local solar noon)
        var mid = sunrise + TimeSpan.FromTicks(dayLen.Ticks / 2);
        var abhijitSpan = TimeSpan.FromTicks(dayLen.Ticks / 15);
        var abhijitStart = mid - TimeSpan.FromTicks(abhijitSpan.Ticks / 2);
        var abhijitEnd = abhijitStart.Add(abhijitSpan);
        vardhyam = $"{abhijitStart:HH:mm}-{abhijitEnd:HH:mm}";

        // Subha Samaya = Daytime excluding Rahu, Yama, Durmuhurtham windows
        var blocked = new List<(DateTime s, DateTime e)> { (rkStart, rkEnd), (ygStart, ygEnd) };
        foreach (var idx in dayDurMuh)
        {
            var s = sunrise.AddTicks(muhurta.Ticks * (idx - 1));
            var e = s.Add(muhurta);
            blocked.Add((s, e));
        }
        // merge overlaps
        blocked = blocked.OrderBy(b => b.s).ToList();
        var merged = new List<(DateTime s, DateTime e)>();
        foreach (var b in blocked)
        {
            if (merged.Count == 0 || b.s > merged[^1].e)
                merged.Add(b);
            else
                merged[^1] = (merged[^1].s, b.e > merged[^1].e ? b.e : merged[^1].e);
        }
        // compute complements inside [sunrise, sunset]
        var subha = new List<string>();
        DateTime cursor = sunrise;
        foreach (var b in merged)
        {
            if (b.s > cursor)
                subha.Add($"{cursor:HH:mm}-{b.s:HH:mm}");
            if (b.e > cursor) cursor = b.e;
        }
        if (cursor < sunset)
            subha.Add($"{cursor:HH:mm}-{sunset:HH:mm}");
        subhaSamaya = subha.Count == 0 ? "None" : string.Join(", ", subha);
    }
}
